"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createErrorMsg = exports.sift = exports.clone = exports.isArray = void 0;
var CloneDataType;
(function (CloneDataType) {
    CloneDataType["Boolean"] = "boolean";
    CloneDataType["Number"] = "number";
    CloneDataType["Function"] = "function";
    CloneDataType["String"] = "string";
    CloneDataType["Buffer"] = "buffer";
    CloneDataType["Object"] = "object";
    CloneDataType["Array"] = "array";
    CloneDataType["Date"] = "date";
    CloneDataType["RegExp"] = "regexp";
})(CloneDataType || (CloneDataType = {}));
const isArray = (value) => {
    return value !== undefined
        && value !== null
        && Array.isArray(value);
};
exports.isArray = isArray;
// sanitize removes undefined & null fields from object. default false
const clone = (obj, sanitize) => {
    let result;
    if (obj) {
        let type = typeof obj;
        if (type === CloneDataType.Object) {
            const objAsObject = obj;
            if ((0, exports.isArray)(objAsObject)) {
                type = CloneDataType.Array;
            }
            else if (objAsObject instanceof Date) {
                type = CloneDataType.Date;
            }
            else if (objAsObject instanceof RegExp) {
                type = CloneDataType.RegExp;
            }
            else if (objAsObject.byteLength
                && typeof objAsObject.byteLength === 'function') {
                type = CloneDataType.Buffer;
            }
        }
        switch (type) {
            case CloneDataType.Date: {
                const objAsDate = obj;
                result = new Date(objAsDate);
                break;
            }
            case CloneDataType.Array: {
                const objAsArray = obj;
                result = objAsArray.map((one) => {
                    return (0, exports.clone)(one);
                });
                break;
            }
            case CloneDataType.Object: {
                // sanitize default false
                result = {};
                const entries = Object.entries(obj)
                    .filter(([, value]) => {
                    return sanitize
                        ? value !== undefined && value !== null
                        : true;
                });
                for (const [key, value] of entries) {
                    // call recursively
                    result[key] = (0, exports.clone)(value, sanitize);
                }
                break;
            }
            default:
                // simple copy
                result = obj;
        }
    }
    else {
        result = obj; // do not copy null & undefined
    }
    return result;
};
exports.clone = clone;
const sift = (arr) => {
    return arr.reduce((acc, cur) => {
        if (cur !== null && cur !== undefined && !acc.includes(cur)) {
            acc.push(cur);
        }
        return acc;
    }, []);
};
exports.sift = sift;
const createErrorMsg = (errorMsg, param) => {
    let result = errorMsg;
    if (param === null || param === void 0 ? void 0 : param.placeholders) {
        param.placeholders.forEach((strToReplace, i) => {
            result = result.replace(`<<${i + 1}>>`, typeof strToReplace === 'string'
                ? strToReplace
                : '' + strToReplace);
        });
    }
    return result;
};
exports.createErrorMsg = createErrorMsg;
//# sourceMappingURL=util.js.map