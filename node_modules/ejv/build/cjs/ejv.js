"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ejv = void 0;
const interfaces_1 = require("./interfaces.js");
const constants_1 = require("./constants.js");
const tester_1 = require("./tester.js");
const util_1 = require("./util.js");
function _getEffectiveTypes(scheme) {
    let result;
    if ((0, tester_1.definedTester)(scheme.type)) {
        result = ((0, tester_1.arrayTester)(scheme.type)
            ? scheme.type
            : [scheme.type]);
    }
    else if ((0, tester_1.definedTester)(scheme.parent)) {
        result = _getEffectiveTypes(scheme.parent);
    }
    return result;
}
const _ejv = (data, schemes, options) => {
    var _a, _b, _c, _d, _e;
    // check schemes
    if (!(0, tester_1.definedTester)(schemes) || schemes === null) {
        return new interfaces_1.EjvError({
            type: constants_1.ErrorType.NO_SCHEME,
            message: constants_1.ErrorMsg.NO_SCHEME,
            data: data,
            errorScheme: schemes,
            isSchemeError: true
        });
    }
    if (!(0, tester_1.arrayTester)(schemes)) {
        return new interfaces_1.EjvError({
            type: constants_1.ErrorType.INVALID_SCHEMES,
            message: constants_1.ErrorMsg.NO_ARRAY_SCHEME,
            data: data,
            errorScheme: schemes,
            isSchemeError: true
        });
    }
    if (!(0, tester_1.arrayTypeOfTester)(schemes, constants_1.DataType.OBJECT)) {
        return new interfaces_1.EjvError({
            type: constants_1.ErrorType.INVALID_SCHEMES,
            message: constants_1.ErrorMsg.NO_OBJECT_ARRAY_SCHEME,
            data: data,
            errorScheme: schemes,
            isSchemeError: true
        });
    }
    if (!(0, tester_1.minLengthTester)(schemes, 1)) {
        return new interfaces_1.EjvError({
            type: constants_1.ErrorType.INVALID_SCHEMES,
            message: constants_1.ErrorMsg.EMPTY_SCHEME,
            data: data,
            errorScheme: schemes,
            isSchemeError: true
        });
    }
    // check data by schemes
    let result = null;
    // use for() instead of forEach() to stop
    for (const scheme of schemes) {
        const key = scheme.key;
        const _options = (0, util_1.clone)(options); // divide instance
        let value;
        if (key) {
            value = data[key];
            _options.path.push(key);
        }
        const types = _getEffectiveTypes(scheme);
        if (!(0, tester_1.definedTester)(types)) {
            return new interfaces_1.EjvError({
                type: constants_1.ErrorType.INVALID_SCHEMES,
                message: constants_1.ErrorMsg.SCHEMES_SHOULD_HAVE_TYPE,
                data: data,
                errorScheme: scheme,
                isSchemeError: true
            });
        }
        const allDataType = Object.values(constants_1.DataType);
        const typeError = types.find((type) => {
            return !(0, tester_1.definedTester)(type)
                || !(0, tester_1.stringTester)(type)
                || !(0, tester_1.enumTester)(type, allDataType);
        });
        if (typeError) {
            return new interfaces_1.EjvError({
                type: constants_1.ErrorType.INVALID_SCHEMES,
                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.SCHEMES_HAS_INVALID_TYPE, {
                    placeholders: [typeError]
                }),
                data: data,
                errorScheme: scheme,
                isSchemeError: true
            });
        }
        if (!(0, tester_1.uniqueItemsTester)(types)) {
            const notUniqueItems = types.filter((type) => {
                return types.filter((_type) => _type === type).length > 1;
            });
            const notUniqueItemsSifted = (0, util_1.sift)(notUniqueItems);
            return new interfaces_1.EjvError({
                type: constants_1.ErrorType.INVALID_SCHEMES,
                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.SCHEMES_HAS_DUPLICATED_TYPE, {
                    placeholders: [notUniqueItemsSifted.join(', ')]
                }),
                data: data,
                errorScheme: scheme,
                isSchemeError: true
            });
        }
        if (!(0, tester_1.definedTester)(value)) {
            if (scheme.optional !== true) {
                result = new interfaces_1.EjvError({
                    type: constants_1.ErrorType.REQUIRED,
                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.REQUIRED),
                    data,
                    path: _options.path,
                    errorScheme: scheme,
                    errorData: value
                });
                break;
            }
            else {
                continue;
            }
        }
        if (value === null) {
            if (scheme.nullable !== true) {
                result = new interfaces_1.EjvError({
                    type: constants_1.ErrorType.REQUIRED,
                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.REQUIRED),
                    data,
                    path: _options.path,
                    errorScheme: scheme,
                    errorData: value
                });
                break;
            }
            else {
                continue;
            }
        }
        const typeResolved = types.find((type) => {
            return (0, tester_1.typeTester)(value, type);
        });
        if (typeResolved) {
            if ((0, tester_1.definedTester)(scheme.type)) {
                if (!(0, tester_1.arrayTester)(scheme.type)) {
                    if (scheme.type !== typeResolved) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.TYPE_MISMATCH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH, {
                                placeholders: [scheme.type]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: scheme,
                            errorData: value
                        });
                    }
                }
                else {
                    if (!scheme.type.includes(typeResolved)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.TYPE_MISMATCH_ONE_OF,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH_ONE_OF, {
                                placeholders: [JSON.stringify(scheme.type)]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: scheme,
                            errorData: value
                        });
                    }
                }
            }
            // else do additional validation
        }
        else {
            // type is not resolved
            const typesForMsg = scheme.type || ((_a = scheme.parent) === null || _a === void 0 ? void 0 : _a.type);
            if (!(0, tester_1.arrayTester)(typesForMsg)) {
                result = new interfaces_1.EjvError({
                    type: constants_1.ErrorType.TYPE_MISMATCH,
                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH, {
                        placeholders: [typesForMsg]
                    }),
                    data,
                    path: _options.path,
                    errorScheme: scheme,
                    errorData: value
                });
            }
            else {
                result = new interfaces_1.EjvError({
                    type: constants_1.ErrorType.TYPE_MISMATCH_ONE_OF,
                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH_ONE_OF, {
                        placeholders: [JSON.stringify(typesForMsg)]
                    }),
                    data,
                    path: _options.path,
                    errorScheme: scheme,
                    errorData: value
                });
            }
            break;
        }
        // additional check for type resolved
        switch (typeResolved) {
            case constants_1.DataType.NUMBER: {
                const valueAsNumber = value;
                const numberScheme = scheme;
                if ((0, tester_1.definedTester)(numberScheme.enum)) {
                    if (!(0, tester_1.arrayTester)(numberScheme.enum)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ENUM_SHOULD_BE_ARRAY),
                            data: data,
                            errorScheme: numberScheme,
                            isSchemeError: true
                        });
                    }
                    const enumArr = numberScheme.enum;
                    if (!(0, tester_1.arrayTypeOfTester)(enumArr, constants_1.DataType.NUMBER)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ENUM_SHOULD_BE_NUMBERS),
                            data: data,
                            errorScheme: numberScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.enumTester)(valueAsNumber, enumArr)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.ONE_VALUE_OF,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ONE_VALUE_OF, {
                                placeholders: [JSON.stringify(enumArr)]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: numberScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(numberScheme.min)
                    || (0, tester_1.definedTester)((_b = scheme.parent) === null || _b === void 0 ? void 0 : _b.min)) {
                    const effectiveMin = numberScheme.min || ((_c = scheme.parent) === null || _c === void 0 ? void 0 : _c.min);
                    if (!(0, tester_1.numberTester)(effectiveMin)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_SHOULD_BE_NUMBER),
                            data: data,
                            errorScheme: numberScheme,
                            isSchemeError: true
                        });
                    }
                    if ((0, tester_1.definedTester)(numberScheme.exclusiveMin)) {
                        if (!(0, tester_1.booleanTester)(numberScheme.exclusiveMin)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.EXCLUSIVE_MIN_SHOULD_BE_BOOLEAN),
                                data: data,
                                errorScheme: numberScheme,
                                isSchemeError: true
                            });
                        }
                    }
                    if (numberScheme.exclusiveMin) {
                        if (!(0, tester_1.exclusiveMinNumberTester)(valueAsNumber, effectiveMin)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.BIGGER_THAN,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.BIGGER_THAN, {
                                    placeholders: [effectiveMin]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                    else {
                        if (!(0, tester_1.minNumberTester)(valueAsNumber, effectiveMin)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.BIGGER_THAN_OR_EQUAL,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.BIGGER_THAN_OR_EQUAL, {
                                    placeholders: [effectiveMin]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                }
                if ((0, tester_1.definedTester)(numberScheme.max)
                    || (0, tester_1.definedTester)((_d = scheme.parent) === null || _d === void 0 ? void 0 : _d.max)) {
                    const effectiveMax = numberScheme.max || ((_e = scheme.parent) === null || _e === void 0 ? void 0 : _e.max);
                    if (!(0, tester_1.numberTester)(effectiveMax)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_SHOULD_BE_NUMBER),
                            data: data,
                            errorScheme: numberScheme,
                            isSchemeError: true
                        });
                    }
                    if ((0, tester_1.definedTester)(numberScheme.exclusiveMax)) {
                        if (!(0, tester_1.booleanTester)(numberScheme.exclusiveMax)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.EXCLUSIVE_MAX_SHOULD_BE_BOOLEAN),
                                data: data,
                                errorScheme: numberScheme,
                                isSchemeError: true
                            });
                        }
                    }
                    if (numberScheme.exclusiveMax) {
                        if (!(0, tester_1.exclusiveMaxNumberTester)(valueAsNumber, effectiveMax)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.SMALLER_THAN,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.SMALLER_THAN, {
                                    placeholders: [effectiveMax]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                    else {
                        if (!(0, tester_1.maxNumberTester)(valueAsNumber, effectiveMax)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.SMALLER_THAN_OR_EQUAL,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.SMALLER_THAN_OR_EQUAL, {
                                    placeholders: [effectiveMax]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                }
                if ((0, tester_1.definedTester)(numberScheme.format)) {
                    let formats;
                    const allNumberFormat = Object.values(constants_1.NumberFormat);
                    if (!(0, tester_1.arrayTester)(numberScheme.format)) {
                        const formatAsString = numberScheme.format;
                        if (!(0, tester_1.enumTester)(formatAsString, allNumberFormat)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_NUMBER_FORMAT, {
                                    placeholders: [formatAsString]
                                }),
                                data: data,
                                errorScheme: numberScheme,
                                isSchemeError: true
                            });
                        }
                        formats = [numberScheme.format];
                    }
                    else {
                        const formatAsArray = numberScheme.format;
                        const errorFormat = formatAsArray.find((format) => {
                            return !(0, tester_1.enumTester)(format, allNumberFormat);
                        });
                        if (errorFormat) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_NUMBER_FORMAT, {
                                    placeholders: [errorFormat]
                                }),
                                data: data,
                                errorScheme: numberScheme,
                                isSchemeError: true
                            });
                        }
                        formats = numberScheme.format;
                    }
                    const someFormatIsWrong = formats.some((format) => {
                        let valid = false;
                        switch (format) {
                            case constants_1.NumberFormat.INTEGER:
                                valid = (0, tester_1.integerTester)(valueAsNumber);
                                break;
                            case constants_1.NumberFormat.INDEX:
                                valid = (0, tester_1.indexTester)(valueAsNumber);
                                break;
                        }
                        return valid;
                    });
                    if (!someFormatIsWrong) {
                        if (!(0, tester_1.arrayTester)(numberScheme.format)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.FORMAT,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.FORMAT, {
                                    placeholders: [numberScheme.format]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                        }
                        else {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.FORMAT_ONE_OF,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.FORMAT_ONE_OF, {
                                    placeholders: [JSON.stringify(numberScheme.format)]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: numberScheme,
                                errorData: value
                            });
                        }
                        break;
                    }
                }
                break;
            }
            case constants_1.DataType.STRING: {
                const valueAsString = value;
                const stringScheme = scheme;
                if ((0, tester_1.definedTester)(stringScheme.enum)) {
                    if (!(0, tester_1.arrayTester)(stringScheme.enum)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ENUM_SHOULD_BE_ARRAY),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    const enumArr = stringScheme.enum;
                    if (!(0, tester_1.arrayTypeOfTester)(enumArr, constants_1.DataType.STRING)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ENUM_SHOULD_BE_STRINGS),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.enumTester)(valueAsString, enumArr)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.ONE_VALUE_OF,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ONE_VALUE_OF, {
                                placeholders: [JSON.stringify(stringScheme.enum)]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: stringScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(stringScheme.length)) {
                    const length = stringScheme.length;
                    if (!((0, tester_1.numberTester)(length) && (0, tester_1.integerTester)(length))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.lengthTester)(valueAsString, length)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.LENGTH, {
                                placeholders: [length]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: stringScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(stringScheme.minLength)) {
                    const minLength = stringScheme.minLength;
                    if (!((0, tester_1.numberTester)(minLength) && (0, tester_1.integerTester)(minLength))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.minLengthTester)(valueAsString, minLength)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.MIN_LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_LENGTH, {
                                placeholders: ['' + minLength]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: stringScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(stringScheme.maxLength)) {
                    const maxLength = stringScheme.maxLength;
                    if (!((0, tester_1.numberTester)(maxLength) && (0, tester_1.integerTester)(maxLength))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.maxLengthTester)(valueAsString, maxLength)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.MAX_LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_LENGTH, {
                                placeholders: ['' + maxLength]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: stringScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(stringScheme.format)) {
                    let formats;
                    const allStringFormat = Object.values(constants_1.StringFormat);
                    if (!(0, tester_1.arrayTester)(stringScheme.format)) {
                        const formatAsString = stringScheme.format;
                        if (!(0, tester_1.enumTester)(formatAsString, allStringFormat)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_FORMAT, {
                                    placeholders: [formatAsString]
                                }),
                                data: data,
                                errorScheme: stringScheme,
                                isSchemeError: true
                            });
                        }
                        formats = [stringScheme.format];
                    }
                    else {
                        const formatAsArray = stringScheme.format;
                        const errorFormat = formatAsArray.find((format) => {
                            return !(0, tester_1.enumTester)(format, allStringFormat);
                        });
                        if (errorFormat) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_FORMAT, {
                                    placeholders: [errorFormat]
                                }),
                                data: data,
                                errorScheme: stringScheme,
                                isSchemeError: true
                            });
                        }
                        formats = stringScheme.format;
                    }
                    const foundFormatMatching = formats.some((format) => {
                        let valid = false;
                        switch (format) {
                            case constants_1.StringFormat.EMAIL:
                                valid = (0, tester_1.emailTester)(valueAsString);
                                break;
                            case constants_1.StringFormat.DATE:
                                valid = (0, tester_1.dateFormatTester)(valueAsString);
                                break;
                            case constants_1.StringFormat.TIME:
                                valid = (0, tester_1.timeFormatTester)(valueAsString);
                                break;
                            case constants_1.StringFormat.DATE_TIME:
                                valid = (0, tester_1.dateTimeFormatTester)(valueAsString);
                                break;
                        }
                        return valid;
                    });
                    if (!foundFormatMatching) {
                        if (!(0, tester_1.arrayTester)(stringScheme.format)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.FORMAT,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.FORMAT, {
                                    placeholders: [stringScheme.format]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: stringScheme,
                                errorData: value
                            });
                        }
                        else {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.FORMAT_ONE_OF,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.FORMAT_ONE_OF, {
                                    placeholders: [JSON.stringify(stringScheme.format)]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: stringScheme,
                                errorData: value
                            });
                        }
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(stringScheme.pattern)) {
                    // check parameter
                    if (stringScheme.pattern === null) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_PATTERN, {
                                placeholders: ['null']
                            }),
                            data: data,
                            errorScheme: stringScheme,
                            isSchemeError: true
                        });
                    }
                    const isValidPattern = (pattern) => {
                        return ((0, tester_1.stringTester)(pattern) && (0, tester_1.minLengthTester)(pattern, 1))
                            || ((0, tester_1.regExpTester)(pattern) && pattern.toString() !== '/(?:)/' && pattern.toString() !== '/null/');
                    };
                    const patternToString = (pattern) => {
                        let regExpStr;
                        if (pattern === null) {
                            regExpStr = '/null/';
                        }
                        else if ((0, tester_1.stringTester)(pattern)) {
                            if ((0, tester_1.minLengthTester)(pattern, 1)) {
                                regExpStr = new RegExp(pattern).toString();
                            }
                            else {
                                regExpStr = '//';
                            }
                        }
                        else {
                            regExpStr = pattern.toString();
                        }
                        // empty regular expression
                        if (regExpStr === '/(?:)/') {
                            regExpStr = '//';
                        }
                        return regExpStr;
                    };
                    const createArrayErrorMsg = (patternsAsArray) => {
                        return '[' + patternsAsArray.map((onePattern) => {
                            return patternToString(onePattern);
                        }).join(', ') + ']';
                    };
                    if ((0, tester_1.arrayTester)(stringScheme.pattern)) {
                        const patternsAsArray = stringScheme.pattern;
                        if (!(0, tester_1.minLengthTester)(patternsAsArray, 1)) { // empty array
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_PATTERN, {
                                    placeholders: [createArrayErrorMsg(patternsAsArray)]
                                }),
                                data: data,
                                errorScheme: stringScheme,
                                isSchemeError: true
                            });
                        }
                        try {
                            const regExpPatterns = patternsAsArray.map((pattern) => {
                                if (!isValidPattern(pattern)) {
                                    throw new Error((0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_PATTERN, {
                                        placeholders: [createArrayErrorMsg(patternsAsArray)]
                                    }));
                                }
                                return new RegExp(pattern);
                            });
                            // check value
                            const foundMatchPattern = regExpPatterns.some((regexp) => {
                                return (0, tester_1.stringRegExpTester)(valueAsString, regexp);
                            });
                            if (!foundMatchPattern) {
                                result = new interfaces_1.EjvError({
                                    type: constants_1.ErrorType.PATTERN_ONE_OF,
                                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.PATTERN_ONE_OF, {
                                        placeholders: [createArrayErrorMsg(patternsAsArray)]
                                    }),
                                    data,
                                    path: _options.path,
                                    errorScheme: stringScheme,
                                    errorData: value
                                });
                                break;
                            }
                        }
                        catch (e) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_PATTERN, {
                                    placeholders: [createArrayErrorMsg(patternsAsArray)]
                                }),
                                data: data,
                                errorScheme: stringScheme,
                                isSchemeError: true
                            });
                        }
                    }
                    else {
                        const patternAsOne = stringScheme.pattern;
                        if (!isValidPattern(patternAsOne)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_STRING_PATTERN, {
                                    placeholders: [patternToString(patternAsOne)]
                                }),
                                data: data,
                                errorScheme: stringScheme,
                                isSchemeError: true
                            });
                        }
                        // check value
                        const regExp = new RegExp(patternAsOne);
                        if (!(0, tester_1.stringRegExpTester)(valueAsString, regExp)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.PATTERN,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.PATTERN, {
                                    placeholders: [patternToString(patternAsOne)]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: stringScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                }
                break;
            }
            case constants_1.DataType.OBJECT: {
                const valueAsObject = value;
                const objectScheme = scheme;
                if ((0, tester_1.definedTester)(objectScheme.allowNoProperty)) {
                    if (!(0, tester_1.booleanTester)(objectScheme.allowNoProperty)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ALLOW_NO_PROPERTY_SHOULD_BE_BOOLEAN),
                            data: data,
                            errorScheme: objectScheme,
                            isSchemeError: true
                        });
                    }
                    if (!objectScheme.allowNoProperty && !(0, tester_1.hasPropertyTester)(valueAsObject)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.PROPERTY,
                            message: constants_1.ErrorMsg.PROPERTY,
                            data,
                            path: _options.path,
                            errorScheme: objectScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(objectScheme.properties)) {
                    if (!(0, tester_1.arrayTester)(objectScheme.properties)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.PROPERTIES_SHOULD_BE_ARRAY),
                            data: data,
                            errorScheme: objectScheme,
                            isSchemeError: true
                        });
                    }
                    const properties = objectScheme.properties;
                    if (!(0, tester_1.minLengthTester)(properties, 1)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.PROPERTIES_SHOULD_HAVE_ITEMS),
                            data: data,
                            errorScheme: objectScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.arrayTypeOfTester)(properties, constants_1.DataType.OBJECT)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.PROPERTIES_SHOULD_BE_ARRAY_OF_OBJECT),
                            data: data,
                            errorScheme: objectScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.objectTester)(value)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.TYPE_MISMATCH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH, {
                                placeholders: ['object']
                            }),
                            data,
                            path: _options.path,
                            errorScheme: objectScheme,
                            errorData: value
                        });
                        break;
                    }
                    const partialData = data[key];
                    const partialScheme = objectScheme.properties;
                    scheme.parent = objectScheme;
                    // call recursively
                    result = _ejv(partialData, partialScheme, _options);
                    if (result) {
                        // inject original data
                        result.data = data;
                    }
                }
                break;
            }
            case constants_1.DataType.DATE: {
                const valueAsDate = value;
                const dateScheme = scheme;
                const parentDateScheme = scheme.parent;
                if ((0, tester_1.definedTester)(dateScheme.min)
                    || (0, tester_1.definedTester)(parentDateScheme === null || parentDateScheme === void 0 ? void 0 : parentDateScheme.min)) {
                    const minDateCandidate = dateScheme.min || (parentDateScheme === null || parentDateScheme === void 0 ? void 0 : parentDateScheme.min);
                    if (!(((0, tester_1.stringTester)(minDateCandidate)
                        && ((0, tester_1.dateFormatTester)(minDateCandidate)
                            || (0, tester_1.dateTimeFormatTester)(minDateCandidate)))
                        || (0, tester_1.dateTester)(minDateCandidate))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_DATE_SHOULD_BE_DATE_OR_STRING),
                            data: data,
                            errorScheme: dateScheme,
                            isSchemeError: true
                        });
                    }
                    const effectiveMin = new Date(minDateCandidate);
                    if ((0, tester_1.definedTester)(dateScheme.exclusiveMin)) {
                        if (!(0, tester_1.booleanTester)(dateScheme.exclusiveMin)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.EXCLUSIVE_MIN_SHOULD_BE_BOOLEAN),
                                data: data,
                                errorScheme: dateScheme,
                                isSchemeError: true
                            });
                        }
                        if (dateScheme.exclusiveMin) {
                            if (!(0, tester_1.exclusiveMinDateTester)(valueAsDate, effectiveMin)) {
                                result = new interfaces_1.EjvError({
                                    type: constants_1.ErrorType.AFTER_DATE,
                                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.AFTER_DATE, {
                                        placeholders: [effectiveMin.toISOString()]
                                    }),
                                    data,
                                    path: _options.path,
                                    errorScheme: dateScheme,
                                    errorData: value
                                });
                                break;
                            }
                        }
                        else {
                            if (!(0, tester_1.minDateTester)(valueAsDate, effectiveMin)) {
                                result = new interfaces_1.EjvError({
                                    type: constants_1.ErrorType.AFTER_OR_SAME_DATE,
                                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.AFTER_OR_SAME_DATE, {
                                        placeholders: [effectiveMin.toISOString()]
                                    }),
                                    data,
                                    path: _options.path,
                                    errorScheme: dateScheme,
                                    errorData: value
                                });
                                break;
                            }
                        }
                    }
                    else {
                        if (!(0, tester_1.minDateTester)(valueAsDate, effectiveMin)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.AFTER_OR_SAME_DATE,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.AFTER_OR_SAME_DATE, {
                                    placeholders: [effectiveMin.toISOString()]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: dateScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                }
                if ((0, tester_1.definedTester)(dateScheme.max)
                    || (0, tester_1.definedTester)(parentDateScheme === null || parentDateScheme === void 0 ? void 0 : parentDateScheme.max)) {
                    const maxDateCandidate = dateScheme.max || (parentDateScheme === null || parentDateScheme === void 0 ? void 0 : parentDateScheme.max);
                    if (!(((0, tester_1.stringTester)(maxDateCandidate)
                        && ((0, tester_1.dateFormatTester)(maxDateCandidate)
                            || (0, tester_1.dateTimeFormatTester)(maxDateCandidate)))
                        || (0, tester_1.dateTester)(maxDateCandidate))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_DATE_SHOULD_BE_DATE_OR_STRING),
                            data: data,
                            errorScheme: dateScheme,
                            isSchemeError: true
                        });
                    }
                    const effectiveMax = new Date(maxDateCandidate);
                    if ((0, tester_1.definedTester)(dateScheme.exclusiveMax)) {
                        if (!(0, tester_1.booleanTester)(dateScheme.exclusiveMax)) {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.EXCLUSIVE_MAX_SHOULD_BE_BOOLEAN),
                                data: data,
                                errorScheme: dateScheme,
                                isSchemeError: true
                            });
                        }
                    }
                    if (dateScheme.exclusiveMax) {
                        if (!(0, tester_1.exclusiveMaxDateTester)(valueAsDate, effectiveMax)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.BEFORE_DATE,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.BEFORE_DATE, {
                                    placeholders: [effectiveMax.toISOString()]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: dateScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                    else {
                        if (!(0, tester_1.maxDateTester)(valueAsDate, effectiveMax)) {
                            result = new interfaces_1.EjvError({
                                type: constants_1.ErrorType.BEFORE_OR_SAME_DATE,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.BEFORE_OR_SAME_DATE, {
                                    placeholders: [effectiveMax.toISOString()]
                                }),
                                data,
                                path: _options.path,
                                errorScheme: dateScheme,
                                errorData: value
                            });
                            break;
                        }
                    }
                }
                break;
            }
            case constants_1.DataType.ARRAY: {
                const valueAsArray = value;
                const arrayScheme = scheme;
                if ((0, tester_1.definedTester)(arrayScheme.length)) {
                    const length = arrayScheme.length;
                    if (!((0, tester_1.numberTester)(length) && (0, tester_1.integerTester)(length))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: arrayScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.lengthTester)(valueAsArray, length)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.LENGTH, {
                                placeholders: ['' + length]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: arrayScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(arrayScheme.minLength)) {
                    const minLength = arrayScheme.minLength;
                    if (!((0, tester_1.numberTester)(arrayScheme.minLength) && (0, tester_1.integerTester)(minLength))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: arrayScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.minLengthTester)(valueAsArray, minLength)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.MIN_LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MIN_LENGTH, {
                                placeholders: ['' + minLength]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: arrayScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(arrayScheme.maxLength)) {
                    const maxLength = arrayScheme.maxLength;
                    if (!((0, tester_1.numberTester)(arrayScheme.maxLength) && (0, tester_1.integerTester)(maxLength))) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_LENGTH_SHOULD_BE_INTEGER),
                            data: data,
                            errorScheme: arrayScheme,
                            isSchemeError: true
                        });
                    }
                    if (!(0, tester_1.maxLengthTester)(valueAsArray, maxLength)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.MAX_LENGTH,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.MAX_LENGTH, {
                                placeholders: ['' + maxLength]
                            }),
                            data,
                            path: _options.path,
                            errorScheme: arrayScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(arrayScheme.unique)) {
                    if (!(0, tester_1.booleanTester)(arrayScheme.unique)) {
                        return new interfaces_1.EjvError({
                            type: constants_1.ErrorType.INVALID_SCHEMES,
                            message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.UNIQUE_SHOULD_BE_BOOLEAN),
                            data: data,
                            errorScheme: arrayScheme,
                            isSchemeError: true
                        });
                    }
                    if (arrayScheme.unique && !(0, tester_1.uniqueItemsTester)(valueAsArray)) {
                        result = new interfaces_1.EjvError({
                            type: constants_1.ErrorType.UNIQUE_ITEMS,
                            message: constants_1.ErrorMsg.UNIQUE_ITEMS,
                            data,
                            path: _options.path,
                            errorScheme: arrayScheme,
                            errorData: value
                        });
                        break;
                    }
                }
                if ((0, tester_1.definedTester)(arrayScheme.items)) {
                    // convert array to object
                    if (valueAsArray.length > 0) {
                        const now = new Date();
                        const tempKeyArr = valueAsArray.map((_value, i) => {
                            return '' + (+now + i);
                        });
                        if ((0, tester_1.stringTester)(arrayScheme.items) // by DataType
                            || ((0, tester_1.arrayTester)(arrayScheme.items) && (0, tester_1.arrayTypeOfTester)(arrayScheme.items, constants_1.DataType.STRING)) // by DataType[]
                        ) {
                            const itemTypes = ((0, tester_1.arrayTester)(arrayScheme.items)
                                ? arrayScheme.items
                                : [arrayScheme.items]);
                            const itemTypeError = itemTypes.find((type) => {
                                return !(0, tester_1.definedTester)(type)
                                    || !(0, tester_1.stringTester)(type)
                                    || !(0, tester_1.enumTester)(type, allDataType);
                            });
                            if (itemTypeError) {
                                return new interfaces_1.EjvError({
                                    type: constants_1.ErrorType.INVALID_SCHEMES,
                                    message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.SCHEMES_HAS_INVALID_TYPE, {
                                        placeholders: [itemTypeError]
                                    }),
                                    data: data,
                                    errorScheme: scheme,
                                    isSchemeError: true
                                });
                            }
                            const partialData = {};
                            const partialSchemes = [];
                            tempKeyArr.forEach((tempKey, i) => {
                                partialData[tempKey] = valueAsArray[i];
                                partialSchemes.push({
                                    key: tempKey,
                                    type: itemTypes
                                });
                            });
                            scheme.parent = arrayScheme;
                            // call recursively
                            const partialResult = _ejv(partialData, partialSchemes, _options);
                            // convert new EjvError
                            if (partialResult) {
                                let errorMsg;
                                if ((0, tester_1.arrayTester)(arrayScheme.items)) {
                                    errorMsg = (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ITEMS_TYPE, {
                                        placeholders: [JSON.stringify(itemTypes)]
                                    });
                                }
                                else {
                                    errorMsg = (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ITEMS_TYPE, {
                                        placeholders: [arrayScheme.items]
                                    });
                                }
                                const partialKeys = (partialResult.path || '').split('/');
                                const partialKey = partialKeys[partialKeys.length - 1];
                                const partialScheme = partialSchemes.find((_scheme) => {
                                    return _scheme.key === partialKey;
                                });
                                const partialKeyIndex = partialSchemes.indexOf(partialScheme);
                                result = new interfaces_1.EjvError({
                                    type: constants_1.ErrorType.ITEMS_TYPE,
                                    message: errorMsg,
                                    data,
                                    path: [..._options.path, '' + partialKeyIndex],
                                    errorScheme: partialScheme,
                                    errorData: partialData[partialKey]
                                });
                            }
                            break;
                        }
                        else if (((0, tester_1.objectTester)(arrayScheme.items) && arrayScheme.items !== null) // by Scheme
                            || ((0, tester_1.arrayTester)(arrayScheme.items) && (0, tester_1.arrayTypeOfTester)(arrayScheme.items, constants_1.DataType.OBJECT)) // by Scheme[]
                        ) {
                            const itemsAsSchemes = (0, tester_1.arrayTester)(arrayScheme.items)
                                ? arrayScheme.items
                                : [arrayScheme.items];
                            let partialError = null;
                            // use for() instead of forEach() to break
                            const valueLength = valueAsArray.length;
                            for (let arrIndex = 0; arrIndex < valueLength; arrIndex++) {
                                const oneValue = valueAsArray[arrIndex];
                                const partialData = {};
                                const partialSchemes = [];
                                const tempKeyForThisValue = tempKeyArr[arrIndex];
                                partialData[tempKeyForThisValue] = oneValue;
                                partialSchemes.push(...itemsAsSchemes.map((oneScheme) => {
                                    const newScheme = (0, util_1.clone)(oneScheme); // divide instance
                                    newScheme.key = tempKeyForThisValue;
                                    return newScheme;
                                }));
                                const partialResults = partialSchemes.map((partialScheme) => {
                                    // call recursively
                                    const partialResult = _ejv(partialData, [partialScheme], _options);
                                    if (partialResult) {
                                        partialResult.path = (partialResult.path || '').replace(tempKeyForThisValue, '' + arrIndex);
                                    }
                                    return partialResult;
                                });
                                if (!partialResults.some((oneResult) => oneResult === null)) {
                                    partialError = partialResults.find((oneResult) => {
                                        return !!oneResult;
                                    });
                                    break;
                                }
                            }
                            if (partialError) {
                                let errorType;
                                let errorMsg;
                                if (!!itemsAsSchemes && itemsAsSchemes.length > 1) {
                                    errorType = constants_1.ErrorType.ITEMS_SCHEMES;
                                    errorMsg = (0, util_1.createErrorMsg)(constants_1.ErrorMsg.ITEMS_SCHEMES, {
                                        placeholders: [JSON.stringify(itemsAsSchemes)]
                                    });
                                }
                                else {
                                    errorType = partialError.type;
                                    errorMsg = partialError.message;
                                    if (errorType === constants_1.ErrorType.REQUIRED) {
                                        // REQUIRED in array is TYPE_MISMATCH except with nullable === true
                                        errorType = constants_1.ErrorType.TYPE_MISMATCH;
                                        errorMsg = (0, util_1.createErrorMsg)(constants_1.ErrorMsg.TYPE_MISMATCH, {
                                            placeholders: [JSON.stringify(arrayScheme.items)]
                                        });
                                    }
                                }
                                result = new interfaces_1.EjvError({
                                    type: errorType,
                                    message: errorMsg,
                                    data
                                });
                                if (errorType === constants_1.ErrorType.INVALID_SCHEMES) {
                                    result.errorScheme = arrayScheme;
                                    result.isSchemeError = true;
                                    result.isDataError = false;
                                }
                                else {
                                    result.path = partialError.path;
                                    result.errorData = partialError.errorData;
                                }
                                break;
                            }
                        }
                        else {
                            return new interfaces_1.EjvError({
                                type: constants_1.ErrorType.INVALID_SCHEMES,
                                message: (0, util_1.createErrorMsg)(constants_1.ErrorMsg.INVALID_ITEMS_SCHEME, {
                                    placeholders: [JSON.stringify(arrayScheme.items)]
                                }),
                                data: data,
                                errorScheme: arrayScheme,
                                isSchemeError: true
                            });
                        }
                    }
                }
                break;
            }
        }
        if (result) {
            break;
        }
    }
    if (result !== null && (0, tester_1.definedTester)(options.customErrorMsg)) {
        const customErrorMsgObj = options.customErrorMsg;
        // override error message
        const customMsg = customErrorMsgObj[result.type];
        if ((0, tester_1.definedTester)(customMsg)) {
            result.message = customMsg;
        }
    }
    return result;
};
const ejv = (data, schemes, options) => {
    // check data itself
    if (!(0, tester_1.definedTester)(data) || !(0, tester_1.objectTester)(data) || data === null) {
        return new interfaces_1.EjvError({
            type: constants_1.ErrorType.NO_DATA,
            message: constants_1.ErrorMsg.NO_DATA,
            data: data,
            path: undefined,
            errorScheme: undefined,
            errorData: data,
            isSchemeError: false
        });
    }
    const internalOption = (options
        ? Object.assign({}, options) : {});
    if (!(0, tester_1.definedTester)(internalOption.path)) {
        internalOption.path = [];
    }
    return _ejv(data, schemes, internalOption);
};
exports.ejv = ejv;
//# sourceMappingURL=ejv.js.map