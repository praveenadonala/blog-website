"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.regExpTester = exports.uniqueItemsTester = exports.arrayTypeOfTester = exports.arrayTester = exports.exclusiveMaxDateTester = exports.maxDateTester = exports.exclusiveMinDateTester = exports.minDateTester = exports.dateTester = exports.hasPropertyTester = exports.objectTester = exports.dateTimeFormatTester = exports.timeFormatTester = exports.dateFormatTester = exports.emailTester = exports.stringRegExpTester = exports.stringTester = exports.exclusiveMaxNumberTester = exports.maxNumberTester = exports.exclusiveMinNumberTester = exports.minNumberTester = exports.indexTester = exports.integerTester = exports.numberTester = exports.booleanTester = exports.maxLengthTester = exports.minLengthTester = exports.lengthTester = exports.enumTester = exports.definedTester = exports.typeTester = void 0;
const constants_1 = require("./constants.js");
const typeTester = (value, type) => {
    let valid;
    switch (type) {
        case constants_1.DataType.BOOLEAN:
            valid = (0, exports.booleanTester)(value);
            break;
        case constants_1.DataType.NUMBER:
            valid = (0, exports.numberTester)(value);
            break;
        case constants_1.DataType.STRING:
            valid = (0, exports.stringTester)(value);
            break;
        case constants_1.DataType.OBJECT:
            valid = (0, exports.objectTester)(value);
            break;
        case constants_1.DataType.DATE:
            valid = (0, exports.dateTester)(value);
            break;
        case constants_1.DataType.REGEXP:
            valid = (0, exports.regExpTester)(value);
            break;
        case constants_1.DataType.ARRAY:
            valid = (0, exports.arrayTester)(value);
            break;
    }
    return valid;
};
exports.typeTester = typeTester;
const definedTester = (value) => {
    return value !== undefined;
};
exports.definedTester = definedTester;
const enumTester = (value, arr) => {
    return arr.includes(value);
};
exports.enumTester = enumTester;
const lengthTester = (value, length) => {
    return value.length === length;
};
exports.lengthTester = lengthTester;
const minLengthTester = (value, minLength) => {
    return value.length >= minLength;
};
exports.minLengthTester = minLengthTester;
const maxLengthTester = (value, maxLength) => {
    return value.length <= maxLength;
};
exports.maxLengthTester = maxLengthTester;
const booleanTester = (value) => {
    return typeof value === 'boolean';
};
exports.booleanTester = booleanTester;
const numberTester = (value) => {
    return typeof value === 'number' && !isNaN(value);
};
exports.numberTester = numberTester;
const integerTester = (value) => {
    return +value.toFixed(0) === value;
};
exports.integerTester = integerTester;
const indexTester = (value) => {
    return (0, exports.integerTester)(value) && value >= 0;
};
exports.indexTester = indexTester;
const minNumberTester = (value, min) => {
    return value >= min;
};
exports.minNumberTester = minNumberTester;
const exclusiveMinNumberTester = (value, min) => {
    return value > min;
};
exports.exclusiveMinNumberTester = exclusiveMinNumberTester;
const maxNumberTester = (value, max) => {
    return value <= max;
};
exports.maxNumberTester = maxNumberTester;
const exclusiveMaxNumberTester = (value, max) => {
    return value < max;
};
exports.exclusiveMaxNumberTester = exclusiveMaxNumberTester;
const stringTester = (value) => {
    return typeof value === 'string';
};
exports.stringTester = stringTester;
const stringRegExpTester = (value, regExp) => {
    let valid = false;
    let _regExp = undefined;
    if ((0, exports.regExpTester)(regExp)) {
        _regExp = regExp;
    }
    else if ((0, exports.stringTester)(regExp)) {
        _regExp = new RegExp(regExp);
    }
    if (!!_regExp && (0, exports.regExpTester)(_regExp)) {
        valid = _regExp.test(value);
    }
    return valid;
};
exports.stringRegExpTester = stringRegExpTester;
// RFC 5322, 3.4.1. spec
const emailTester = (value) => {
    let valid = false;
    if ((0, exports.stringTester)(value) && (0, exports.stringRegExpTester)(value, /^.+@.+$/)) {
        const valueAsString = value;
        const atIndex = valueAsString.lastIndexOf('@');
        const localPart = valueAsString.substr(0, atIndex);
        const domain = valueAsString.substr(atIndex + 1);
        // regular expression sources
        // const aTextRegExpStr : string = '[-a-zA-Z0-9!#$%&\\\'*+/=?^_`{|}~]+';
        const dotAtomRegExp = /^(\.?[-a-zA-Z0-9!#$%&'*+/=?^_`{|}~]+)*$/;
        const quotedStringRegExp = /^"[\u0020-\u005b\u005d-\u007e\\]*"$/; // include space (\u005b)
        const domainLiteralRegExp = /^\[[\u0020-\u005a\u005c-\u007e\\]*]$/;
        const validLocalPart = localPart.length <= 64
            && (dotAtomRegExp.test(localPart)
                || quotedStringRegExp.test(localPart));
        const validDomain = !domain.startsWith('.') && !domain.endsWith('.')
            && (dotAtomRegExp.test(domain)
                || domainLiteralRegExp.test(domain));
        valid = validLocalPart && validDomain;
    }
    return valid;
};
exports.emailTester = emailTester;
// RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) : YYYY-MM-DDThh:mm:ss[.SSSZ]
const rfc3339Tester = (value) => {
    return /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3])(:([0-5][0-9])){2}(\.\d+)?(Z|[-+]\d{2}:\d{2})?$/.test(value);
};
const iso8601DateTester = (value) => {
    const years = '(\\d{4})';
    const months = '(0[1-9]|1[0-2])';
    const dates = '(0[1-9]|[1-2][0-9]|3[0-1])';
    const dateOfYear = '(00[1-9]|0[1-9][0-9]|[1-2]\\d{2}|3[0-5]\\d|36[0-6])'; // 366 for leap year
    const weeks = '(W(0[1-9]|[2-4][0-9]|5[0-3]))';
    const days = '[1-7]';
    return [
        new RegExp(`^[-+]?${years}$`), // years : YYYY, +YYYY, -YYYY
        new RegExp(`^${years}-${months}(-${dates})?$`), // calendar dates : YYYY-MM-DD, YYYY-MM
        new RegExp(`^${years}${months}${dates}$`), // calendar dates : YYYYMMDD
        new RegExp(`^--${months}-?${dates}$`), // calendar dates : --MM-DD, --MMDD
        new RegExp(`^${years}-${weeks}(-${days})?$`), // week dates : YYYY-Www, YYYY-Www-D
        new RegExp(`^${years}${weeks}(${days})?$`), // week dates : YYYYWww, YYYYWwwD
        new RegExp(`^${years}-?${dateOfYear}$`) // ordinal dates : YYYY-DDD, YYYYDDD
    ].some((regExp) => {
        return regExp.test(value);
    });
};
const iso8601TimeTester = (value) => {
    const hours = '([0-1]\\d|2[0-3])';
    const minutes = '([0-5]\\d)';
    const seconds = '([0-5]\\d|60)'; // 60 for leap second
    const ms = '(\\.[0-9]+)';
    return [
        new RegExp(`^(${hours}|24)$`), // hh
        new RegExp(`^((${hours}:${minutes})|24:00)$`), // hh:mm
        new RegExp(`^((${hours}:${minutes}:${seconds})|24:00:00)$`), // hh:mm:ss
        new RegExp(`^((${hours}:${minutes}:${seconds}${ms})|24:00:00.0+)$`), // hh:mm:ss
        new RegExp(`^(${hours}${minutes}|2400)$`), // hhmm
        new RegExp(`^(${hours}${minutes}${seconds}|240000)$`), // hhmmss
        new RegExp(`^(${hours}${minutes}${seconds}${ms}|240000.0+)$`) // hhmmss.sss
    ]
        .some((regExp) => {
        return regExp.test(value);
    });
};
const iso8601DateTimeTester = (value) => {
    let valid = false;
    if (/.+T.+/.test(value) // should have 1 'T'
        && /(Z|[-+]\d{2}:?\d{2})$/.test(value) // should end with 'Z' or timezone
    ) {
        const dateAndTime = value.split('T');
        const date = dateAndTime[0];
        let time = dateAndTime[1];
        if (time.endsWith('Z')) {
            time = time.replace('Z', '');
        }
        else {
            const timezoneStartIndex = time.includes('+')
                ? time.indexOf('+')
                : time.indexOf('-');
            time = time.slice(0, timezoneStartIndex);
        }
        valid = iso8601DateTester(date) && iso8601TimeTester(time);
    }
    return valid;
};
const dateFormatTester = (value) => {
    return iso8601DateTester(value);
};
exports.dateFormatTester = dateFormatTester;
const timeFormatTester = (value) => {
    return iso8601TimeTester(value);
};
exports.timeFormatTester = timeFormatTester;
const dateTimeFormatTester = (value) => {
    return rfc3339Tester(value) || iso8601DateTimeTester(value);
};
exports.dateTimeFormatTester = dateTimeFormatTester;
// // with port
// export const urlTester = (value : any) : boolean => {
// 	return stringTester(value)
// 		&& /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value);
// };
//
// // TODO: with port
// export const ipv4Tester = (value : any) : boolean => {
// 	return stringTester(value)
// 		&& /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(value);
// };
//
// export const ipv6Tester = (value : any) : boolean => {
// 	return stringTester(value)
// 		&& /^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$;/.test(value);
// };
//
// export const ipTester = (value : any) : boolean => {
// 	return ipv4Tester(value) || ipv6Tester(value);
// };
const objectTester = (value) => {
    return typeof value === 'object';
};
exports.objectTester = objectTester;
const hasPropertyTester = (value) => {
    return Object.keys(value).length > 0;
};
exports.hasPropertyTester = hasPropertyTester;
const dateTester = (value) => {
    return (0, exports.objectTester)(value)
        && value !== null
        && typeof value === 'object'
        && value instanceof Date
        && !isNaN(value.getFullYear());
};
exports.dateTester = dateTester;
const minDateTester = (value, min) => {
    return +value >= +min;
};
exports.minDateTester = minDateTester;
const exclusiveMinDateTester = (value, min) => {
    return +value > +min;
};
exports.exclusiveMinDateTester = exclusiveMinDateTester;
const maxDateTester = (value, max) => {
    return +value <= +max;
};
exports.maxDateTester = maxDateTester;
const exclusiveMaxDateTester = (value, max) => {
    return +value < +max;
};
exports.exclusiveMaxDateTester = exclusiveMaxDateTester;
const arrayTester = (value) => {
    return Array.isArray(value);
};
exports.arrayTester = arrayTester;
const arrayTypeOfTester = (array, type) => {
    return array.every((item) => {
        return (0, exports.typeTester)(item, type);
    });
};
exports.arrayTypeOfTester = arrayTypeOfTester;
const uniqueItemsTester = (array) => {
    return array.every((item) => {
        return array.filter((target) => target === item).length === 1;
    });
};
exports.uniqueItemsTester = uniqueItemsTester;
const regExpTester = (value) => {
    return value instanceof RegExp;
};
exports.regExpTester = regExpTester;
//# sourceMappingURL=tester.js.map